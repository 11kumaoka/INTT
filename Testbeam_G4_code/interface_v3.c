// bco and bco_full is no longer important for the tree_both analysis
// The first selection : INTT_event, camac_tdc6, camac_adc

//----------------------------------------------------------------------------------------------------------------
// Note by Cheng-Wei Shih @ NCU 2021/11/11
//
// The preselection : INTT_event, camac_adc (if too big, skip), camac_tdc6
// 
// 1. the purpose of this code is to convert the data format of G4 into the data format of Testbeam, then we can use
//    the G4 data to tune our tracking code.
//
// 2. We mainly focus on the study of tree_both. It is a tree combines all the information. I mainly introduce this
//
// 3. for the branch "INTT_event" of tree_both, this is kind of the coincidence signal of scintillators and INTT detectors
//    Here I introduce some cases, if we have one ladder, and the module ID is 5
//
//	  sci1  sci2  sci3 scin-coincidence  INTT_sig   module  INTT_event (coin. of sci-coin. and INTT-sig.)
//      1     1     1        1              1           5      1
//      1     1     0        0              1           5      X  -> this kind of event never happens, because the scin-coincidence is always the first
//      1     1     1        1              X           X      0
//      1     1     1        1              2       all 5      1  -> as long as we have more than one INTT_sig, INTT_event : 1
//      1     1     1        1              2        5, 6      1
//      1     1     1        1              2       all 6      0
//
//   The thing is that it is kind of very hard for G4 to have 3 sci signals but with INTT_sig no hits  
//   **So in the interface code, the INTT_event generated by a random number
//
// 4. INTT_adc : a vector with 3 elements. It is the energy deposit of scintillators.
//    I don't know the correct conversion function. So I just times the G4 sci energy by 120. Their distributions are land.
//    It may can be a cut as well. For example, skip the event with too larger camac_adc 
//
// 5. INTT_tdc : it is a vector with 6 elements, 
//    ele 0 : the time difference between the "common start" and signal arriving time of sci1,      in G4 : random, gaus distribution
//    ele 1 : the time difference between the "common start" and signal arriving time of sci2,      in G4 : random, gaus distribution
//    ele 2 : the time difference between the "common start" and signal arriving time of sci3,      in G4 : random, gaus distribution
//    ele 3 : X
//    ele 4 : X
//    ele 5 : the time difference between the "common start" and signal arriving time of scin-coin, in G4 : random, flat distribution in a certain range
//			  it could be a cut as well. 
//
// 6. the moduleID, adc setting can be modified @ line 133 ~ 144
//
// 7. the energy deposit of INTT ladder is converted into adc by using the function @ line 388
//    the gain and offset can be modified @ line 131, 132
//    ** If the the energy of the hit smaller than the adc0 (15), this hit will be skipped. 
//
// 8. the bco and bco_full is generated randomly. In tree_both, the bco and bco full is no longer important.
//    we use camac_tdc to separate the event
//
// 9. the fpga_id, fem_id and ampl are set to be 0
//
// 10. The parameters you may want to tune
//     A. file_name       @ line 67
//     B. folder_name     @ line 70
//     C. the name of the output file after format conversion @ line 204
//     D. Gain and offset @ line 131 132
//     E. ADC setting     @ line 133 ~ 144
//     F. Module ID       @ line 133 ~ 144
//     G. The range of the random generator of camac_tdc @ line 166 ~ 169
//     H. The efficiency of INTT_event (0 ~ 1) @ line 361
//     I. The force efficiency setting of each layer. @ line 392 393
//
//      
//----------------------------------------------------------------------------------------------------------------


void interface_v3 (TString file_name) // file_name is fed from outside
{
	//the direction of the data
        TString folder_name = "/data4/chengwei/Geant4/INTT_simulation/G4/for_CW/data";
        //use TFile, TTree to open the tree
        TFile *f1 = TFile::Open(Form("%s/%s.root", folder_name.Data(), file_name.Data()));
 	// Chamber1 -> the tree to save the information of INTT ladders in  G4
	TTree *Gettree = (TTree *)f1->Get("Chamber1");
	// sci_trigger -> the tree to save the information of scintillators in G4
	TTree *Gettree_sci = (TTree *)f1->Get("sci_trigger");
	cout<<"we are now work on : "<<file_name<<".root"<<endl;
	int Event_ID, UpandDown, Xpos, Ypos, Zpos, silicon_type;
	double Edep;
	double sci_edep;
	int Event_ID_sci,sci_ID;

	// total channel hits of the whole run, it should be ~ 4 times # of event you set in G4, because the G4 model has 4 ladders 
	int total_size = Gettree->GetEntriesFast();
	cout<<"total entry INTT   : "<<total_size<<endl;

	//The branch in Chamber1, 
	//I divide the INTT sensitive area into 4 region ("Up and down of sensor" * "type A and B") 
	//-> UpandDown & silicon_type -> 1,1   1,0  0,1   0,0
	//Event_ID is the ID to separate the event in G4
	Gettree->SetBranchAddress("Event_ID", &Event_ID);
	Gettree->SetBranchAddress("UpandDown", &UpandDown);
	Gettree->SetBranchAddress("Xpos", &Xpos);
	Gettree->SetBranchAddress("Ypos", &Ypos);
	Gettree->SetBranchAddress("Zpos", &Zpos);
	Gettree->SetBranchAddress("silicon_type", &silicon_type);
	Gettree->SetBranchAddress("Edep", &Edep);//in MeV

	//to get the first event ID of the root file. If you run the G4 with multi-thread, the order of event ID can be disordered, 
	//0 may not be the first one.  
	Gettree->GetEntry(0);
	int event_buffer;
	event_buffer=Event_ID;
	cout<<"First INTT EventID : "<<event_buffer<<endl;


	// total hits of the whole run, it should be ~ 3 times # of event you set in G4, because the G4 model has 3 layers of scintillator 
	int total_size_sci = Gettree_sci->GetEntriesFast();
	cout<<"total entry SCI    : "<<total_size_sci<<endl;

	//the branch in sci_trigger
	//sci_ID from 0 to 2 (3 scintillators)
	Gettree_sci->SetBranchAddress("Event_ID",&Event_ID_sci);
	Gettree_sci->SetBranchAddress("sci_ID",&sci_ID);
	Gettree_sci->SetBranchAddress("sci_edep",&sci_edep);

	//to get the first event ID of the root file. If you run the G4 with multi-thread, the order of event ID can be disordered, 
	//0 may not be the first one.  
	//it can be different with INTT event_ID, if the first sci or INTT get nothing.   
	Gettree_sci->GetEntry(0); 
	int event_buffer_sci = Event_ID_sci;
	cout<<"First SCI EventID  : "<<event_buffer_sci<<endl;
	
	vector<int> sci_array_samll;    sci_array_samll.clear();
	vector<vector<int>> sci_array;  sci_array.clear();
	vector<int> sci_eventID_array;       sci_eventID_array.clear();
	sci_eventID_array.push_back(event_buffer_sci);

	//the setting of Gain, offset, ADC setting and module ID is here
	int adc, ampl, chip_id, fpga_id, module, chan_id, fem_id, bco, bco_full, event;
	double Gain=100;
	double offset=200;
	int set_DAC0=15;
	int set_DAC1=30;
	int set_DAC2=60;
	int set_DAC3=90;
	int set_DAC4=120;
	int set_DAC5=150;
	int set_DAC6=180;
	int set_DAC7=210;
	int module_id_l0=6;
	int module_id_l1=5;
	int module_id_l2=8;
	int module_id_l3=2;
	double ev_DAC_convert;
	
	// the random generator for bco and bco_full
	TRandom *rand_bcofull = new TRandom3 ( 0 );
	UInt16 Frand_bcofull = int(rand_bcofull->Uniform(0.,65536.)); //0 ~ 65535
	//int Frand_bco =  int(rand_bco->Uniform(0.,128.)); //0 ~ 127
	UInt16 Frand_bco = Frand_bcofull & UInt16( 255 ); // take the lowest 7 bits from the BCO full
	
	int event_count=0;
	vector<int> camac_adc; camac_adc.clear();
	vector<int> camac_tdc; camac_tdc.clear();
	vector<vector<int>> camac_tdc_all; camac_tdc_all.clear();
	bool INTT_event;
	vector<bool> INTT_event_all; INTT_event_all.clear();

	// the random generator for camac_tdc
	// the range I use is beased on the cosmic test result from NWU
	TRandom *rand_tdc1 = new TRandom3 ( 0 );
	TRandom *rand_tdc2 = new TRandom3 ( 0 );
	TRandom *rand_tdc3 = new TRandom3 ( 0 );
	TRandom *rand_tdc6 = new TRandom3 ( 0 );
	TRandom *rand_INTT_event = new TRandom3 ( 0 );
	int Frand_tdc1 = int (rand_tdc1->Gaus(148,12.5));
	int Frand_tdc2 = int (rand_tdc2->Gaus(139.7,0.87));
	int Frand_tdc3 = int (rand_tdc3->Gaus(128,12.3));
	int Frand_tdc6 = int (rand_tdc6->Uniform(520.,1080.));

	//the random generator for INTT_event 
	double Frand_INTT_event = rand_INTT_event -> Uniform(0,1); 
	int tree_counting=0;
	int first_sci_with_3_index = -1;
	int first_sci_INTT_match_index;
	int match_finder_check=0;
	int loop_match_finder=0;
	int loop_match_finder_check=0;

	vector<int> adc_array;      adc_array.clear();
	vector<int> ampl_array;     ampl_array.clear();
	vector<int> chip_id_array;  chip_id_array.clear();
	vector<int> fpga_id_array;  fpga_id_array.clear();
	vector<int> module_array;   module_array.clear();
	vector<int> chan_id_array;  chan_id_array.clear();
	vector<int> fem_id_array;   fem_id_array.clear();
	//vector<int>	bco_array;      bco_array.clear();
	vector<UInt16>	bco_array;      bco_array.clear();
	//	vector<int> bco_full_array; bco_full_array.clear();
	vector<UInt16> bco_full_array; bco_full_array.clear();
	vector<int> event_array;    event_array.clear();

	// vector<vector<int>> adc_array_all;      adc_array_all.clear();
	// vector<vector<int>> ampl_array_all;     ampl_array_all.clear();
	// vector<vector<int>> chip_id_array_all;  chip_id_array_all.clear();
	// vector<vector<int>> fpga_id_array_all;  fpga_id_array_all.clear();
	// vector<vector<int>> module_array_all;   module_array_all.clear();
	// vector<vector<int>> chan_id_array_all;  chan_id_array_all.clear();
	// vector<vector<int>> fem_id_array_all;   fem_id_array_all.clear();
	// vector<vector<int>>	bco_array_all;      bco_array_all.clear();
	// vector<vector<int>> bco_full_array_all; bco_full_array_all.clear();
	// vector<vector<int>> event_array_all;    event_array_all.clear();

	//the name of the output file
	//here is the part to create the trees, branches of the output file
	TFile *file_output = new TFile(Form("%s/%s_convert.root", folder_name.Data(), file_name.Data()), "RECREATE");
	TTree *tree_output1 = new TTree("tree", "tree");
	TTree *tree_output2 = new TTree("tree_camac", "tree_camac");
	TTree *tree_output3 = new TTree("tree_both", "tree_both");
	
	tree_output1->Branch("adc"     , &adc);
	tree_output1->Branch("ampl"    , &ampl); 
	tree_output1->Branch("chip_id" , &chip_id);
	tree_output1->Branch("fpga_id" , &fpga_id); //0
	tree_output1->Branch("module"  , &module);
	//assume we use 
	//C-1 for layer-0 (6)
	//C-2 for layer-1 (5)
	//C-3 for layer-2 (8)
	//A-1 for layer-3 (2)
	tree_output1->Branch("chan_id" , &chan_id);
	tree_output1->Branch("fem_id"  , &fem_id); //0
	tree_output1->Branch("bco"     , &bco);
	tree_output1->Branch("bco_full", &bco_full);
	tree_output1->Branch("event"   , &event); //fed by event_count, to avoid the case that edep<adc0
	
	tree_output2->Branch("camac_adc",&camac_adc); //edep*120 directly, I don't know the conversion function
	tree_output2->Branch("camac_tdc",&camac_tdc);
	tree_output2->Branch("INTT_event",&INTT_event); //0 or 1, generated randomly. 

	tree_output3->Branch("camac_adc" ,&camac_adc);
	tree_output3->Branch("camac_tdc" ,&camac_tdc);
	tree_output3->Branch("INTT_event",&INTT_event);
	tree_output3->Branch("adc"       ,&adc_array);
	tree_output3->Branch("ampl"      ,&ampl_array);
	tree_output3->Branch("chip_id"   ,&chip_id_array);
	tree_output3->Branch("fpga_id"   ,&fpga_id_array);
	tree_output3->Branch("module"    ,&module_array);
	tree_output3->Branch("chan_id"   ,&chan_id_array);
	tree_output3->Branch("fem_id"    ,&fem_id_array);
	tree_output3->Branch("bco"       ,&bco_array);
	tree_output3->Branch("bco_full"  ,&bco_full_array);
	tree_output3->Branch("event"     ,&event_array); //-1 for always


	// here is the part to convert the sci information of same event into a vector
	// The event_ID_sci is use to separate event
	// sci_array is a 2D vector[eventID][the hit information]
	for (int i=0; i<total_size_sci; i++)
	{
		Gettree_sci->GetEntry(i);

		if (Event_ID_sci == event_buffer_sci)
		{
			sci_array_samll.push_back(int(sci_edep*120.)); // camac_adc = sci_edep*120;

		}
		else
		{
			event_buffer_sci = Event_ID_sci;
			sci_array.push_back(sci_array_samll);
			sci_array_samll.clear();
			sci_array_samll.push_back(int(sci_edep*120.)); // camac_adc = sci_edep*120;

			sci_eventID_array.push_back(event_buffer_sci);
		}
	}
	
	sci_array.push_back(sci_array_samll);
	sci_array_samll.clear();

	//here is the part to find out the eventID of the first event with 3 sci hits && at least 1 INTT ladders signal.
	//it is possible that only 2 or 1 sci hits in one event, or 3 sci hits but no INTT signal
	//the 3 hits scintillator coincidence signal is the first selection. 
	for (int i=0; i<sci_array.size(); i++)
	{
		for (int i1=0; i1<total_size; i1++)
		{
			Gettree->GetEntry(i1);
			if (sci_array[i].size() == 3 && Event_ID == sci_eventID_array[i] )
			{
				first_sci_with_3_index = i;
				first_sci_INTT_match_index = i1;
				break;
			}	
		}
		if (first_sci_with_3_index >-1)
		{
			break;
		}
	}

	cout<<"first sci with 3 hits, index "<<first_sci_with_3_index<<" event ID : "<<sci_eventID_array[first_sci_with_3_index]<<endl;
	cout<<"first sci INTT match index   "<<first_sci_INTT_match_index<<endl;

	// for (int i=0; i<sci_array.size(); i++)
	// {
	// 	Frand_tdc1 = int (rand_tdc1->Gaus(148,12.5));
	// 	Frand_tdc2 = int (rand_tdc2->Gaus(139.7,0.87));
	// 	Frand_tdc3 = int (rand_tdc3->Gaus(128,12.3));
	// 	Frand_tdc6 = int (rand_tdc6->Uniform(520.,1080.));
	// 	Frand_INTT_event = rand_INTT_event -> Uniform(0,1);
		
	// 	camac_adc = sci_array[i];
	// 	camac_tdc.push_back(Frand_tdc1);
	// 	camac_tdc.push_back(Frand_tdc2);
	// 	camac_tdc.push_back(Frand_tdc3);
	// 	camac_tdc.push_back(0);
	// 	camac_tdc.push_back(0);
	// 	camac_tdc.push_back(Frand_tdc6);
	// 	camac_tdc_all.push_back(camac_tdc);

	// 	if (Frand_INTT_event<0.9)
	// 	{
	// 		INTT_event = 1;
	// 	}
	// 	else
	// 	{
	// 		INTT_event = 0;
	// 	}
	// 	INTT_event_all.push_back(INTT_event);

	// 	if (sci_array[i].size() == 3)
	// 	{	
	// 		tree_output2->Fill();
	// 	}
	// 	camac_adc.clear();
	// 	camac_tdc.clear();
	// }

	cout<<"sci event after event classify : "<<sci_array.size()<<endl; 

	//the random generator for focibly reducing the layer efficiency
	TRandom *skip_event = new TRandom3(); //  ( 0 ); // use this to have randomly-initialized random number
	double Fskip_event;

	for (int i=0; i<sci_array.size(); i++)
	{
		if (i%3000 == 0){ printf("we are now working on : %i \n",i); }
		
		// the first criteria, 3 scintillators singals is required (equals to 1 coincidence signal)
		if (sci_array[i].size() == 3) // first selection
		{ 
			//generate the random number for camac_tdc and INTT_event
			//the range is based on the cosmic test result from NWU
			Frand_tdc1 = int (rand_tdc1->Gaus(148,12.5));
			Frand_tdc2 = int (rand_tdc2->Gaus(139.7,0.87));
			Frand_tdc3 = int (rand_tdc3->Gaus(128,12.3));
			Frand_tdc6 = int (rand_tdc6->Uniform(520.,1080.));
			Frand_INTT_event = rand_INTT_event -> Uniform(0,1);
			
			//the adc of scintillators
			camac_adc = sci_array[i]; 

			//here we create the camac_tdc information 
			camac_tdc.push_back(Frand_tdc1);
			camac_tdc.push_back(Frand_tdc2);
			camac_tdc.push_back(Frand_tdc3);
			camac_tdc.push_back(0);
			camac_tdc.push_back(0);
			camac_tdc.push_back(Frand_tdc6);

			if (Frand_INTT_event<0.9) // the setting of INTT_event efficiency is here. Now is set to be 90%
			{
				INTT_event = 1;
			}
			else
			{
				INTT_event = 0;
			}
			tree_output2->Fill();

			// it is possible that the order of sci and INTT ladders are not match so well. 
			// In the G4, the sci and INTT ladders are kind of 2 independent system. But it is not the case in practical
			// So I use 2 for loop, one is for sci, another one is for INTT, aiming to connect the info. of both.
			// Once the match happen, the inner loop will break
			for ( int i1=loop_match_finder; i1<total_size; i1++)
			{
				Gettree->GetEntry(i1);
				if (i%3000 == 0){printf(" %i the second loop : %i \n",i, i1);}

				
				//here is the "if" function trying to make sci order and INTT order matched 
				//Event_ID the ID for INTT ladder
				if ( Event_ID == sci_eventID_array[i] )
				{	
					if (i%3000 == 0){printf(" One match \n");}

					// the edep conversion function from MeV -> mV -> adc
					ev_DAC_convert = (Edep*100*1.6*Gain/3.6+offset-210.)/4.;
					loop_match_finder_check=i1;

					// **the 2 lines below is the function to forcibly reduce the layer efficiency
					// Fskip_event = skip_event-> Uniform(0,1);
					// if (Zpos == 1 && Fskip_event > 0.7) {continue;}

					// if the INTT si edep is too small -> skip
					if (ev_DAC_convert<=set_DAC0) // second selection (first selection : sci.size()==3)
					{
						continue;
					}
					else
					{	
						// match_finder_check is a variable to let me know we have at least a signal pass 1 and 2 selection
						match_finder_check+=1;
						fpga_id=0;
						fpga_id_array.push_back(fpga_id);
						fem_id=0;
						fem_id_array.push_back(fem_id);
						ampl=0;
						ampl_array.push_back(ampl);
						event=event_count;
						event_array.push_back(-1);// the -1 is for the tree_both
						
						// here is the part to convert the Xpos, Ypos, Zpos into module, chip_id and chan_id by using the UpandDown
						if (UpandDown==1) // upper
						{
							chan_id = 127-Ypos;
							chip_id = 13-Xpos;
							chip_id_array.push_back(chip_id);
							chan_id_array.push_back(chan_id);
						}
						else //down
						{
							chan_id = Ypos;
							chip_id = 26-Xpos;	
							chip_id_array.push_back(chip_id);
							chan_id_array.push_back(chan_id);
						}

						// here we define the module ID by using Zpos
						if (Zpos == 0)
						{
							module = module_id_l0;
							module_array.push_back(module);
						}
						if (Zpos == 1)
						{
							module = module_id_l1;
							module_array.push_back(module);
						}
						if (Zpos == 2)
						{
							module = module_id_l2;
							module_array.push_back(module);
						}
						if (Zpos == 3)
						{
							module = module_id_l3;
							module_array.push_back(module);
						}

						//here we save the ADC, from MeV to adc finally. 
						if (ev_DAC_convert<=set_DAC0) {continue;}
						else if (ev_DAC_convert>set_DAC0 && ev_DAC_convert<=set_DAC1){adc=0; adc_array.push_back(adc);}
						else if (ev_DAC_convert>set_DAC1 && ev_DAC_convert<=set_DAC2){adc=1; adc_array.push_back(adc);}
						else if (ev_DAC_convert>set_DAC2 && ev_DAC_convert<=set_DAC3){adc=2; adc_array.push_back(adc);}
						else if (ev_DAC_convert>set_DAC3 && ev_DAC_convert<=set_DAC4){adc=3; adc_array.push_back(adc);}
						else if (ev_DAC_convert>set_DAC4 && ev_DAC_convert<=set_DAC5){adc=4; adc_array.push_back(adc);}
						else if (ev_DAC_convert>set_DAC5 && ev_DAC_convert<=set_DAC6){adc=5; adc_array.push_back(adc);}
						else if (ev_DAC_convert>set_DAC6 && ev_DAC_convert<=set_DAC7){adc=6; adc_array.push_back(adc);}
						else{adc=7; adc_array.push_back(adc);}

						//here is the part for bco and bco_full, as long as the "Event_id of G4" doesn't change, the bco and bco_full are the same.
						if (Event_ID == event_buffer)
						{
							bco=Frand_bco;
							bco_full=Frand_bcofull;
							bco_array.push_back(bco);
							bco_full_array.push_back(bco_full);
						}
						else // Once the "Event_id of G4" changes, the random generator will generates a new bco and bco_full
						{
						  //Frand_bco =  int(rand_bco->Uniform(0.,128.)); //0 ~ 127
							Frand_bcofull = int(rand_bcofull->Uniform(0.,65536.)); //0 ~ 65535
							Frand_bco = Frand_bcofull & UInt16( 255 ); // take the lowest 7 bits from the BCO full
							bco=Frand_bco;
							bco_full=Frand_bcofull;
							event_buffer=Event_ID;
							bco_array.push_back(bco);
							bco_full_array.push_back(bco_full);

						}

						tree_output1->Fill(); //tree

						// this "if" bracket is for filling the final event. Otherwise the final event will not be saved.
						if (i == sci_array.size()-1 && i1==total_size-1)
						{
							tree_output3->Fill(); 
						}

						event_count+=1;
					}

					
				}
				// all the hits within same event are checked.
				else if (match_finder_check !=0 )
				{
					if (i%3000 == 0)printf("\n");
					match_finder_check = 0;
					tree_output3->Fill();
					
					fpga_id_array.clear();
					fem_id_array.clear();
					ampl_array.clear();
					event_array.clear();
					chan_id_array.clear();
					chip_id_array.clear();
					module_array.clear();
					bco_array.clear();
					bco_full_array.clear();
					adc_array.clear();
					break;
				}
			} 	
			// the begining value of the innter loop is not always from 0. in order to make the code run faster
			loop_match_finder = loop_match_finder_check;
			camac_adc.clear();
			camac_tdc.clear();		
			
		}
		
	}

	file_output->cd();
	//cout<<"testtest"<<endl;
	tree_output1->Write("", TObject::kOverwrite);
	tree_output2->Write("", TObject::kOverwrite);
	tree_output3->Write("", TObject::kOverwrite);
	cout<<"conversion done "<<endl;
	file_output->Close();


	// for (int i=0; i<sci_array.size(); i++)
	// {
	// 	for (int i1=0; i1<sci_array[i].size(); i1++)
	// 	{
	// 		cout<<"loop index : "<<i<<" event ID : "<<sci_eventID_array[i]<<" edep : "<<sci_array[i][i1]<<endl;
	// 	}
	// 	cout<<" "<<endl;
	// }








}
